<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CIP / CDD Sample Selection</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>
  <script src="./sample_size.js"></script>
  <style>
    /* ============================================
       CIP/CDD Sample Selection - Production UI
       Professional, clean, enterprise-ready design
       ============================================ */
    :root {
      --bg: #f8fafc;
      --panel: #ffffff;
      --accent: #1e40af;
      --accent-2: #2563eb;
      --muted: #64748b;
      --text: #1e293b;
      --success: #15803d;
      --danger: #b91c1c;
      --border: #e2e8f0;
      --pill: #f1f5f9;
      --shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    main {
      width: min(1800px, 100% - 32px);
      margin: 0 auto;
      padding: 24px 16px 40px;
      display: grid;
      gap: 16px;
    }
    header {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px 24px;
      box-shadow: var(--shadow);
    }
    header h1 {
      margin: 0 0 4px 0;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text);
      letter-spacing: -0.025em;
    }
    header p {
      margin: 0;
      color: var(--muted);
      font-size: 0.875rem;
    }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: minmax(460px, 2fr) minmax(320px, 1fr);
      grid-template-areas:
        "main side"
        "plan side"
        "stats review";
      align-items: stretch;
      grid-auto-rows: minmax(min-content, 1fr);
    }
    .grid-main { grid-area: main; }
    .grid-side { grid-area: side; }
    .grid-stats { grid-area: stats; }
    .grid-plan { grid-area: plan; }
    .grid-review { grid-area: review; }
    .grid-stats,
    .grid-review {
      height: 100%;
    }
    @media (max-width: 1100px) {
      .grid {
        grid-template-columns: 1fr;
        grid-template-areas:
          "main"
          "side"
          "plan"
          "stats"
          "review";
      }
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px 24px;
      box-shadow: var(--shadow);
      overflow: hidden;
      height: auto;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .panel h2 {
      margin: 0 0 16px 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }
    .muted { color: var(--muted); }
    .dropzone {
      border: 1px dashed var(--border);
      border-radius: 6px;
      padding: 24px 20px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease;
      background: #fafbfc;
    }
    .dropzone:hover {
      border-color: var(--accent);
      background: #f8fafc;
    }
    .dropzone.dragging {
      border-color: var(--accent);
      background: rgba(30,64,175,0.04);
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 4px;
      background: var(--pill);
      color: var(--text);
      font-size: 0.75rem;
      font-weight: 500;
      margin: 3px 4px 3px 0;
      border: 1px solid var(--border);
      height: 28px;
      box-sizing: border-box;
      white-space: nowrap;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    label {
      display: block;
      font-weight: 500;
      font-size: 0.875rem;
      margin: 14px 0 6px;
      color: var(--text);
    }
    input[type="number"],
    select,
    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 0.875rem;
      font-family: inherit;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    input[type="number"]:focus,
    select:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(30,64,175,0.1);
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .checkboxes label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin: 0;
      font-weight: 500;
      font-size: 0.875rem;
      padding: 8px 12px;
      background: var(--pill);
      border-radius: 6px;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: border-color 0.15s ease;
    }
    .checkboxes label:hover {
      border-color: var(--accent);
    }
    .checkboxes input {
      accent-color: var(--accent);
    }
    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 16px;
      align-items: center;
    }
    button {
      border: none;
      border-radius: 6px;
      padding: 10px 16px;
      font-weight: 600;
      font-size: 0.875rem;
      font-family: inherit;
      cursor: pointer;
      color: #ffffff;
      background: var(--accent);
      transition: background 0.15s ease;
    }
    button:hover:not(:disabled) {
      background: var(--accent-2);
    }
    button.secondary {
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
    }
    button.secondary:hover:not(:disabled) {
      background: var(--pill);
      border-color: #cbd5e1;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .pill-success { border-color: #bbf7d0; color: var(--success); background: #f0fdf4; }
    .pill-danger { border-color: #fecaca; color: var(--danger); background: #fef2f2; }
    .summary {
      background: #fafbfc;
      border-radius: 6px;
      padding: 16px;
      border: 1px solid var(--border);
      border-left: 3px solid var(--accent);
      max-height: none;
      min-height: 140px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text);
      font-size: 0.875rem;
      line-height: 1.6;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 4px;
      background: var(--pill);
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 0.75rem;
      font-weight: 500;
      margin: 0 8px 8px 0;
      height: 28px;
      box-sizing: border-box;
    }
    .progress {
      width: 100%;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
    }
    .progress-bar {
      height: 100%;
      width: 30%;
      background: var(--accent);
      animation: progress-slide 1.2s ease-in-out infinite;
    }
    @keyframes progress-slide {
      0% { transform: translateX(-100%); }
      50% { transform: translateX(50%); }
      100% { transform: translateX(200%); }
    }
    .hint {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 4px;
      word-break: break-word;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      min-width: 0;
      font-size: 0.875rem;
    }
    th, td {
      text-align: left;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      vertical-align: middle;
      white-space: nowrap;
    }
    th {
      color: var(--muted);
      font-weight: 600;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      background: #fafbfc;
    }
    td input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 0.8125rem;
    }
    .plan-scroll {
      overflow: visible;
      max-width: 100%;
      padding-bottom: 6px;
      display: block;
    }
    .action-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      margin: 8px 0 12px;
    }
    .action-card {
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px 14px;
    }
    .buttons.tight {
      gap: 8px;
      margin-top: 8px;
    }
    .status-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      padding: 12px 16px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: var(--shadow);
      font-size: 0.8125rem;
      color: var(--text);
    }
    .pill.badge {
      margin: 0;
      padding: 6px 10px;
    }
    .badge-warn {
      background: #fffbeb;
      border-color: #fde68a;
      color: #b45309;
    }
    .badge-ok {
      background: #f0fdf4;
      border-color: #bbf7d0;
      color: #15803d;
    }
    .help-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--pill);
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 0.625rem;
      margin-left: 4px;
      cursor: help;
    }
    .focus-ring:focus-visible, button:focus-visible, input:focus-visible, select:focus-visible, .dropzone:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .table-zebra tbody tr:nth-child(odd) {
      background: #fafbfc;
    }
    .table-zebra thead th {
      position: sticky;
      top: 0;
      background: #f1f5f9;
      z-index: 1;
      color: var(--text);
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 4px;
      background: var(--pill);
      border: 1px solid var(--border);
      font-size: 0.75rem;
      font-weight: 500;
      margin: 4px 6px 0 0;
      color: var(--text);
      height: 28px;
      box-sizing: border-box;
    }
    .chip button {
      border: none;
      background: transparent;
      cursor: pointer;
      color: var(--muted);
      font-weight: 700;
      padding: 0 4px;
      font-size: 0.875rem;
    }
    .chip button:hover {
      color: var(--danger);
    }
    .recent-list {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .recent-item {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--panel);
      cursor: pointer;
      font-size: 0.75rem;
      transition: border-color 0.15s ease;
    }
    .recent-item:hover {
      border-color: var(--accent);
    }
    .file-chip {
      margin-top: 10px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 10px 14px;
      background: #f1f5f9;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--text);
    }
    .typeahead {
      width: 100%;
      margin: 6px 0;
    }
    .stats-pane {
      margin-top: 16px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
    }
    .stats-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .stats-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 14px 16px;
    }
    .stats-card h3 {
      margin: 0 0 12px 0;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text);
    }
    .table-wrap {
      overflow: visible;
      width: 100%;
    }
    .strata-card {
      margin-top: 12px;
      grid-column: 1 / -1;
    }
    .strata-table th:first-child,
    .strata-table td:first-child {
      position: sticky;
      left: 0;
      background: #fafbfc;
      z-index: 1;
    }
    .strata-table {
      table-layout: auto;
      width: 100%;
    }
    .strata-table th,
    .strata-table td {
      white-space: normal;
    }
    .stat-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .stat-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 4px;
      background: var(--pill);
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 0.75rem;
      white-space: nowrap;
      height: 28px;
      box-sizing: border-box;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .stat-pill strong { font-weight: 600; }
    .stat-muted {
      color: var(--muted);
      font-size: 0.75rem;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>CIP / CDD Sample Selection</h1>
      <p class="muted">Client-side Excel sampling with statistical defaults (99% / 5% / 1%). Drag and drop your file to begin.</p>
    </header>
    <div class="status-bar" id="statusBar" aria-live="polite">
      <span class="pill badge badge-warn">No dataset loaded</span>
    </div>

    <div class="grid">
      <section class="panel grid-main">
        <h2>1) Load your Excel</h2>
        <div id="dropzone" class="dropzone" tabindex="0">
          <strong>Drag & drop</strong> an Excel file (.xlsx, .xls, .xlsm, .xlsb)<br>
          or <label for="fileInput" style="color: var(--accent); cursor: pointer; text-decoration: underline;">browse</label>
          <div class="hint" id="sheetNameHint"></div>
        </div>
        <input id="fileInput" type="file" accept=".xlsx,.xls,.xlsm,.xlsb" style="display:none" />
        <div class="buttons" style="margin-top:10px;">
          <button type="button" id="demoBtn" class="secondary">Load demo data</button>
        </div>
        <div id="fileMeta" class="file-chip" style="display:none;"></div>
        <div id="recentUploads" class="recent-list"></div>
        <div id="columns" style="margin-top:12px;"></div>
        <div id="populationMeta" class="hint"></div>
        <div class="row">
          <div>
            <label for="populationOverride">Population size override (optional)</label>
            <input type="number" id="populationOverride" name="populationOverride" placeholder="auto" min="1">
            <div class="hint">Use to test sample sizing; overrides detected population size.</div>
          </div>
        </div>
      </section>

      <section class="panel grid-side">
        <h2>2) Configure sampling</h2>
        <form id="configForm">
          <label for="method">Method</label>
          <select id="method" name="method">
            <option value="statistical" selected>Statistical (default)</option>
            <option value="simple_random">Simple random</option>
            <option value="percentage">Percentage of population</option>
            <option value="systematic">Systematic</option>
          </select>

          <div class="row">
            <div>
              <label for="confidence">Desired Confidence Level (%) <span class="help-icon" title="Enter confidence as a percent (e.g., 99).">"</span></label>
              <input type="number" step="any" id="confidence" name="confidence" value="99" min="50" max="99.9">
            </div>
            <div>
              <label for="margin">Tolerable Error Rate (%) <span class="help-icon" title="Enter tolerable error as a percent (e.g., 5).">"</span></label>
              <input type="number" step="any" id="margin" name="margin" value="5" min="0.01" max="100">
            </div>
            <div>
              <label for="expectedError">Expected Error Rate (%) <span class="help-icon" title="Enter the expected percent of errors (e.g., 1 for 1%).">"</span></label>
              <input type="number" step="any" id="expectedError" name="expectedError" value="1" min="0" max="100">
            </div>
          </div>

        <div class="row">
          <div>
            <label for="sampleSize">Sample size (optional) <span class="help-icon" title="Override to a fixed size. Used by simple random / systematic, or as override.">"</span></label>
            <input type="number" id="sampleSize" name="sampleSize" placeholder="auto">
            <div class="hint">Use for simple random/systematic, or override.</div>
          </div>
          <div>
            <label for="samplePct">Sample % (optional) <span class="help-icon" title="Percentage of population to sample.">"</span></label>
            <input type="number" id="samplePct" name="samplePct" placeholder="e.g. 10">
            <div class="hint">Use with percentage/simple_random/systematic.</div>
          </div>
          <div>
            <label for="systematicStep">Systematic step (optional) <span class="help-icon" title="Interval for systematic sampling. Leave blank for auto.">"</span></label>
            <input type="number" id="systematicStep" name="systematicStep" placeholder="auto">
          </div>
        </div>

          <div id="overrideJustificationWrapper" style="display:none;">
            <label for="overrideJustification">Override justification (required when using overrides)</label>
            <textarea id="overrideJustification" name="overrideJustification" rows="4" style="width:100%;min-height:120px;" placeholder="Explain why overrides are used."></textarea>
          </div>

          <label for="stratifySelect">Stratify by</label>
          <input class="typeahead" list="stratifyOptionsList" id="stratifySelect" name="stratifySelect" placeholder="Type to add stratify field" aria-label="Type to add stratify field" disabled>
          <datalist id="stratifyOptionsList"></datalist>
          <div class="hint">Select a column and press Enter to add. You can add multiple fields.</div>
          <div id="stratifyChips"></div>

          <label for="idColumnInput">ID column (optional)</label>
          <input class="typeahead" list="idColumnOptions" id="idColumnInput" name="idColumnInput" placeholder="Type to search columns">
          <datalist id="idColumnOptions"></datalist>

          <div class="checkboxes" style="margin-top:12px;">
            <label><input type="checkbox" id="editRandomizerToggle"> Edit Randomizer</label>
          </div>
          <div id="randomizerSection" class="row" style="display:none;">
            <div>
              <label for="seed">Random seed</label>
              <input type="number" id="seed" name="seed" value="42">
            </div>
            <div>
              <label for="randomStart">Systematic random start</label>
              <select id="randomStart" name="randomStart">
                <option value="yes" selected>Yes (default)</option>
                <option value="no">No</option>
              </select>
            </div>
          </div>

          <div class="buttons">
            <button type="button" id="planBtn" disabled>Plan sample</button>
            <button type="submit" id="runBtn" disabled>Generate sample</button>
            <button type="button" class="secondary" id="resetBtn">Reset</button>
          </div>
          <div class="hint" id="status" aria-live="polite"></div>
        </form>
      </section>

      <section class="panel grid-stats">
        <h2>Population & sample distribution</h2>
        <div class="stats-pane" id="statsPane">Run sampling to see summary statistics.</div>
      </section>

      <section class="panel grid-plan">
        <h2>3) Plan allocation</h2>
        <div id="planBox" class="hint">Load data and click "Plan sample" to see per-stratum counts.</div>
      </section>

      <section class="panel grid-review">
        <h2>4) Review & download</h2>
        <div class="action-grid">
          <div class="action-card">
            <div class="buttons tight">
              <button type="button" id="downloadCsv" disabled>Download sample CSV</button>
              <button type="button" class="secondary" id="downloadJson" disabled>Download JSON summary</button>
            </div>
            <div class="hint">Sample and JSON update each time you generate.</div>
          </div>
        </div>
        <div class="summary" id="summaryBox">Load data and run sampling to see results.</div>
        <div id="overrideNote" class="hint"></div>
        <div style="margin-top:12px;">
          <h3>AI-Generated Summary</h3>
          <div class="buttons tight" style="margin-bottom:8px;">
            <button type="button" id="genSummaryBtn" disabled>Generate AI Summary</button>
          </div>
          <div class="hint" id="summaryStatus"></div>
          <textarea id="aiSummaryText" style="width:100%;min-height:280px;white-space:pre-wrap;" readonly placeholder="Generate a sample first, then click 'Generate AI Summary' to create an AI-written narrative report."></textarea>
        </div>
      </section>
    </div>
  </main>

  <script>
    const MISSING_VALUE = "<MISSING>";
    const DEMO_INLINE = [
      { Customer: "Acme Corp", Region: "NA", RiskBand: "Low", Segment: "SMB", Balance: 120000, TenureMonths: 18 },
      { Customer: "Beta LLC", Region: "NA", RiskBand: "Medium", Segment: "SMB", Balance: 95000, TenureMonths: 10 },
      { Customer: "Cobalt Inc", Region: "EMEA", RiskBand: "High", Segment: "Enterprise", Balance: 450000, TenureMonths: 42 },
      { Customer: "Delta Co", Region: "APAC", RiskBand: "Low", Segment: "Mid", Balance: 210000, TenureMonths: 24 },
      { Customer: "Echo Ltd", Region: "APAC", RiskBand: "Medium", Segment: "Mid", Balance: 175000, TenureMonths: 16 },
      { Customer: "Foxtrot AG", Region: "EMEA", RiskBand: "Low", Segment: "Mid", Balance: 99000, TenureMonths: 8 },
      { Customer: "Garnet BV", Region: "EMEA", RiskBand: "Medium", Segment: "SMB", Balance: 64000, TenureMonths: 12 },
      { Customer: "Helix SA", Region: "LATAM", RiskBand: "High", Segment: "Mid", Balance: 305000, TenureMonths: 30 },
      { Customer: "Iota PLC", Region: "LATAM", RiskBand: "Low", Segment: "SMB", Balance: 58000, TenureMonths: 6 },
      { Customer: "Juno Pty", Region: "NA", RiskBand: "High", Segment: "Enterprise", Balance: 520000, TenureMonths: 50 },
      { Customer: "Kilo GmbH", Region: "EMEA", RiskBand: "Medium", Segment: "Enterprise", Balance: 260000, TenureMonths: 28 },
      { Customer: "Lumen SAS", Region: "APAC", RiskBand: "Low", Segment: "SMB", Balance: 73000, TenureMonths: 14 },
    ];
    const state = {
      population: [],
      columns: [],
      sample: [],
      summary: null,
      sheetName: null,
      fileName: null,
      plan: null,
      report: '',
      recentUploads: [],
      stratifySelected: [],
      fileMeta: null,
      overrideJustification: '',
      lastConfig: null,
    };

    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const demoBtn = document.getElementById('demoBtn');
    const columnsEl = document.getElementById('columns');
    const stratifySelect = document.getElementById('stratifySelect');
    const stratifyOptionsList = document.getElementById('stratifyOptionsList');
    const stratifyChipsEl = document.getElementById('stratifyChips');
    const idColumnInput = document.getElementById('idColumnInput');
    const idColumnOptions = document.getElementById('idColumnOptions');
    const populationMetaEl = document.getElementById('populationMeta');
    const populationOverrideInput = document.getElementById('populationOverride');
    const statusEl = document.getElementById('status');
    const summaryBox = document.getElementById('summaryBox');
    const overrideNoteEl = document.getElementById('overrideNote');
    const genSummaryBtn = document.getElementById('genSummaryBtn');
    const aiSummaryTextEl = document.getElementById('aiSummaryText');
    const summaryStatusEl = document.getElementById('summaryStatus');
    const editRandomizerToggle = document.getElementById('editRandomizerToggle');
    const REPORT_FUNCTION_URL = 'https://frolicking-dusk-5c6419.netlify.app/.netlify/functions/report';
    const randomizerSection = document.getElementById('randomizerSection');
    const overrideJustificationEl = document.getElementById('overrideJustification');
    const overrideJustificationWrapper = document.getElementById('overrideJustificationWrapper');
    const sheetNameHint = document.getElementById('sheetNameHint');
    const fileMetaEl = document.getElementById('fileMeta');
    const recentUploadsEl = document.getElementById('recentUploads');
    const statusBarEl = document.getElementById('statusBar');

    const planBtn = document.getElementById('planBtn');
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const downloadCsvBtn = document.getElementById('downloadCsv');
    const downloadJsonBtn = document.getElementById('downloadJson');
    const planBox = document.getElementById('planBox');

    function setStatus(msg, tone = 'muted') {
      statusEl.textContent = msg;
      statusEl.style.color = tone === 'danger' ? 'var(--danger)' : tone === 'success' ? 'var(--success)' : 'var(--muted)';
      updateStatusBar();
    }

    function normalizeValue(value) {
      if (value === null || value === undefined || (typeof value === 'number' && Number.isNaN(value))) {
        return MISSING_VALUE;
      }
      return value;
    }

    function formatBytes(bytes) {
      if (!bytes && bytes !== 0) return 'n/a';
      const units = ['B','KB','MB','GB'];
      let i = 0;
      let val = bytes;
      while (val >= 1024 && i < units.length - 1) {
        val /= 1024;
        i++;
      }
      return `${val.toFixed(val >= 10 ? 0 : 1)} ${units[i]}`;
    }

    function updateStatusBar() {
      if (!statusBarEl) return;
      if (!state.population.length) {
        statusBarEl.innerHTML = `<span class="pill badge badge-warn">No dataset loaded</span>`;
        return;
      }
      const samplePart = state.sample.length ? `<span class="pill badge badge-ok">Sample: ${state.sample.length.toLocaleString()}</span>` : '';
      const stratifyPart = state.stratifySelected.length ? `<span class="pill badge">Stratify: ${state.stratifySelected.join(', ')}</span>` : '';
      const strataCountPart = state.plan && state.plan.allocations ? `<span class="pill badge">Strata: ${state.plan.allocations.length}</span>` : '';
      statusBarEl.innerHTML = `
        <span class="pill badge badge-ok">Population: ${state.population.length.toLocaleString()}</span>
        ${samplePart}
        ${stratifyPart}
        ${strataCountPart}
      `;
    }

    function renderFileMeta() {
      if (!fileMetaEl) return;
      const meta = state.fileMeta;
      if (!meta) {
        fileMetaEl.style.display = 'none';
        fileMetaEl.textContent = '';
        return;
      }
      fileMetaEl.style.display = 'inline-flex';
      const modified = meta.lastModified ? new Date(meta.lastModified).toLocaleString() : 'n/a';
      fileMetaEl.textContent = `File: ${meta.name} - ${formatBytes(meta.size)} - Modified: ${modified}`;
    }

    function addRecentUpload(entry) {
      state.recentUploads = [entry, ...state.recentUploads.filter(r => r.name !== entry.name)].slice(0, 3);
      renderRecentUploads();
    }

    function loadInlineDemo(label = 'Demo (inline)') {
      state.fileName = label;
      state.sheetName = 'Demo';
      state.population = DEMO_INLINE;
      state.columns = Object.keys(DEMO_INLINE[0]);
      state.sample = [];
      state.summary = null;
      state.plan = null;
      state.stratifySelected = [];
      state.fileMeta = { name: label, size: DEMO_INLINE.length, lastModified: null };
      addRecentUpload({
        name: label,
        sheetName: 'Demo',
        population: state.population,
        columns: state.columns,
        size: DEMO_INLINE.length,
        lastModified: null,
      });
      renderColumns();
      renderStratifyOptions();
      renderPlan();
      renderSummary();
      renderStats();
      renderFileMeta();
      planBtn.disabled = false;
      runBtn.disabled = true;
      sheetNameHint.textContent = `Using sheet: Demo (${label})`;
      setStatus(`Loaded inline demo (${state.population.length} rows).`, 'success');
    }

    function renderRecentUploads() {
      if (!recentUploadsEl) return;
      if (!state.recentUploads.length) {
        recentUploadsEl.textContent = '';
        return;
      }
      recentUploadsEl.innerHTML = state.recentUploads.map((r, idx) => {
        const modified = r.lastModified ? new Date(r.lastModified).toLocaleDateString() : 'n/a';
        return `<div class="recent-item" data-recent="${idx}" title="Use ${r.name} (${r.population.length.toLocaleString()} rows)">` +
          `${r.name} - ${r.population.length.toLocaleString()} rows - ${modified}</div>`;
      }).join('');
      recentUploadsEl.querySelectorAll('.recent-item').forEach(item => {
        item.addEventListener('click', (e) => {
          const idx = parseInt(e.currentTarget.getAttribute('data-recent'), 10);
          const r = state.recentUploads[idx];
          if (!r) return;
          state.population = r.population;
          state.columns = r.columns;
          state.sheetName = r.sheetName;
          state.fileName = r.name;
          state.fileMeta = { name: r.name, size: r.size, lastModified: r.lastModified };
          state.plan = null;
          state.summary = null;
          state.sample = [];
          renderColumns();
          renderStratifyOptions();
          renderPlan();
          renderSummary();
          renderStats();
          planBtn.disabled = false;
          runBtn.disabled = true;
          setStatus(`Reused ${r.population.length.toLocaleString()} rows from ${r.name}.`, 'success');
          const labelText = r.name ? ` (${r.name})` : '';
          sheetNameHint.textContent = `Using sheet: ${r.sheetName}${labelText}`;
        });
      });
    }

    function renderColumns() {
      if (!state.columns.length) {
        columnsEl.innerHTML = '';
        populationMetaEl.textContent = '';
        updateStatusBar();
        return;
      }
      columnsEl.innerHTML = state.columns.map(col => `<span class="pill">${col}</span>`).join('');
      populationMetaEl.textContent = `${state.population.length.toLocaleString()} records loaded${state.sheetName ? ` from sheet "${state.sheetName}"` : ''}.`;
      updateStatusBar();
    }

    function renderStratifyOptions() {
      if (!state.columns.length) {
        if (stratifySelect) {
          stratifySelect.value = '';
          stratifySelect.placeholder = 'Load a file to pick columns';
          stratifySelect.disabled = true;
        }
        if (stratifyOptionsList) stratifyOptionsList.innerHTML = '';
        stratifyChipsEl.innerHTML = '';
        idColumnOptions.innerHTML = '';
        return;
      }
      if (stratifySelect) {
        stratifySelect.disabled = false;
        stratifySelect.placeholder = 'Type to add stratify field';
        stratifySelect.value = '';
      }
      if (stratifyOptionsList) {
        stratifyOptionsList.innerHTML = state.columns.map(col => `<option value="${col}"></option>`).join('');
      }
      idColumnOptions.innerHTML = `<option value=""></option>` + state.columns.map(col => `<option value="${col}">${col}</option>`).join('');
      renderStratifyChips();
    }

    function renderStratifyChips() {
      if (!stratifyChipsEl) return;
      if (!state.stratifySelected.length) {
        stratifyChipsEl.innerHTML = '';
        return;
      }
      stratifyChipsEl.innerHTML = state.stratifySelected.map(val => `
        <span class="chip">${val} <button type="button" aria-label="Remove ${val}" data-chip="${val}">x</button></span>
      `).join('');
      stratifyChipsEl.querySelectorAll('button[data-chip]').forEach(btn => {
        btn.addEventListener('click', () => {
          const val = btn.getAttribute('data-chip');
          setStratifySelection(val, false);
        });
      });
    }

    function setStratifySelection(value, checked) {
      if (checked) {
        if (!state.stratifySelected.includes(value)) {
          state.stratifySelected.push(value);
        }
      } else {
        state.stratifySelected = state.stratifySelected.filter(v => v !== value);
      }
      state.plan = null;
      renderStratifyChips();
    }

    function handleFiles(files) {
      if (!files || !files.length) return;
      const file = files[0];
      state.fileName = file.name;
      state.plan = null;
      state.fileMeta = { name: file.name, size: file.size, lastModified: file.lastModified };
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          processWorkbook(data, file.name, state.fileMeta);
        } catch (err) {
          console.error(err);
          setStatus('Failed to read Excel file. Ensure it has a header row.', 'danger');
        }
      };
      reader.readAsArrayBuffer(file);
    }

    function processWorkbook(uint8array, fileNameLabel = 'Loaded file', meta = null) {
      const workbook = XLSX.read(uint8array, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      state.sheetName = sheetName;
      const ws = workbook.Sheets[sheetName];
      const json = XLSX.utils.sheet_to_json(ws, { defval: null });
      if (!json.length) {
        setStatus('Sheet is empty.', 'danger');
        return;
      }
      state.population = json;
      state.columns = Object.keys(json[0]);
      state.sample = [];
      state.summary = null;
      state.plan = null;
      state.stratifySelected = [];
      state.fileMeta = meta;
      addRecentUpload({
        name: state.fileName || fileNameLabel,
        sheetName: state.sheetName,
        population: state.population,
        columns: state.columns,
        size: meta ? meta.size : null,
        lastModified: meta ? meta.lastModified : null,
      });
      renderColumns();
      renderStratifyOptions();
      renderPlan();
      renderSummary();
      renderStats();
      renderFileMeta();
      setStatus(`Loaded ${json.length} rows from ${sheetName}.`, 'success');
      planBtn.disabled = false;
      runBtn.disabled = true;
      const labelText = fileNameLabel ? ` (${fileNameLabel})` : '';
      sheetNameHint.textContent = `Using first sheet: ${sheetName}${labelText}`;
    }

    function setupDropzone() {
      ['dragenter', 'dragover'].forEach(evt => {
        dropzone.addEventListener(evt, e => {
          e.preventDefault();
          e.stopPropagation();
          dropzone.classList.add('dragging');
        });
      });
      ['dragleave', 'drop'].forEach(evt => {
        dropzone.addEventListener(evt, e => {
          e.preventDefault();
          e.stopPropagation();
          dropzone.classList.remove('dragging');
        });
      });
      dropzone.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
      dropzone.addEventListener('click', () => fileInput.click());
      dropzone.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          fileInput.click();
        }
      });
      fileInput.addEventListener('change', e => handleFiles(e.target.files));
      demoBtn.addEventListener('click', async () => {
        setStatus('Loading demo data...', 'muted');
        try {
          const demoPath = new URL('./synthetic_onboarding_data.xlsx', window.location.href).toString() + '?ts=' + Date.now();
          const resp = await fetch(demoPath, { cache: 'no-store' });
          if (!resp.ok) throw new Error(`Demo file not found (${resp.status})`);
          const buf = await resp.arrayBuffer();
          state.fileName = 'synthetic_onboarding_data.xlsx';
          state.plan = null;
          state.fileMeta = { name: 'synthetic_onboarding_data.xlsx', size: buf.byteLength, lastModified: null };
          processWorkbook(new Uint8Array(buf), 'Demo file (synthetic_onboarding_data.xlsx)', state.fileMeta);
          setStatus('Demo data loaded.', 'success');
        } catch (err) {
          console.error(err);
          setStatus('Could not load demo file; using inline demo.', 'danger');
          loadInlineDemo('Demo (inline fallback)');
        }
      });
    }

    function rngFactory(seed = 42) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = t;
        r = Math.imul(r ^ r >>> 15, r | 1);
        r ^= r + Math.imul(r ^ r >>> 7, r | 61);
        return ((r ^ r >>> 14) >>> 0) / 4294967296;
      };
    }

    function shuffle(arr, rng) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function randomSample(arr, size, rng) {
      if (size <= 0) return [];
      const take = Math.min(arr.length, size);
      return shuffle(arr, rng).slice(0, take);
    }

    function systematicSample(arr, size, randomStart, rng) {
      const n = arr.length;
      if (size <= 0) return [];
      if (size >= n) return arr.slice();
      const offset = randomStart ? Math.floor(rng() * Math.ceil(n / size)) : 0;
      const indices = [];
      for (let k = 0; k < size; k++) {
        const base = Math.floor((k * n) / size);
        indices.push((base + offset) % n);
      }
      return indices.map(i => arr[i]);
    }

    function zScore(confidence) {
      const c = Math.max(0.001, Math.min(0.999, confidence));
      try {
        return jStat.normal.inv(1 - (1 - c) / 2, 0, 1);
      } catch {
        // fallback common values
        if (Math.abs(c - 0.95) < 1e-3) return 1.96;
        if (Math.abs(c - 0.99) < 1e-3) return 2.576;
        if (Math.abs(c - 0.90) < 1e-3) return 1.645;
        return 2.576;
      }
    }

    function resolveSampleSize(N, cfg) {
      if (N <= 0) return 0;
      const method = cfg.method;
      let size = 0;
      const overrideSize = Number.isFinite(cfg.sampleSize) ? Math.max(0, Math.min(N, Math.floor(cfg.sampleSize))) : null;
      if (overrideSize !== null) return overrideSize;
      if (method === 'statistical') {
        size = sampleSize(N, cfg.confidence, cfg.margin, cfg.expectedErrorRate);
      } else if (method === 'percentage') {
        if (cfg.samplePercentage == null) throw new Error('samplePercentage is required for percentage sampling.');
        size = Math.ceil(N * (cfg.samplePercentage / 100));
      } else if (method === 'simple_random') {
        if (cfg.sampleSize == null && cfg.samplePercentage == null) throw new Error('Provide sampleSize or samplePercentage for simple_random.');
        size = cfg.sampleSize != null ? cfg.sampleSize : Math.ceil(N * (cfg.samplePercentage / 100));
      } else if (method === 'systematic') {
        if (cfg.sampleSize != null) {
          size = cfg.sampleSize;
        } else if (cfg.samplePercentage != null) {
          size = Math.ceil(N * (cfg.samplePercentage / 100));
        } else {
          size = sampleSize(N, cfg.confidence, cfg.margin, cfg.expectedErrorRate);
        }
      } else {
        throw new Error(`Unsupported method ${method}`);
      }
      return Math.max(0, Math.min(N, Math.floor(size)));
    }

    function normalizeKey(values) {
      return JSON.stringify(values.map(v => normalizeValue(v)));
    }

    function proportionalAllocation(countsMap, totalSize) {
      const entries = Object.entries(countsMap);
      if (!entries.length || totalSize <= 0) return Object.fromEntries(entries.map(([k]) => [k, 0]));
      const total = entries.reduce((s, [, c]) => s + c, 0);
      const raw = entries.map(([k, c]) => [k, (c / total) * totalSize]);
      const base = new Map(raw.map(([k, v]) => [k, Math.floor(v)]));
      let remainder = totalSize - Array.from(base.values()).reduce((s, v) => s + v, 0);
      if (remainder > 0) {
        const fractional = raw.map(([k, v]) => [k, v - Math.floor(v)]).sort((a, b) => b[1] - a[1]);
        for (let i = 0; i < fractional.length && remainder > 0; i++, remainder--) {
          const key = fractional[i][0];
          base.set(key, (base.get(key) || 0) + 1);
        }
      }
      // Cap by stratum size
      for (const [k, c] of entries) {
        if ((base.get(k) || 0) > c) base.set(k, c);
      }
      // Adjust downward if over
      let current = Array.from(base.values()).reduce((s, v) => s + v, 0);
      while (current > totalSize) {
        const sorted = Array.from(base.entries()).sort((a, b) => b[1] - a[1]);
        for (const [k, v] of sorted) {
          if (current <= totalSize) break;
          if (v > 0) {
            base.set(k, v - 1);
            current -= 1;
          }
        }
      }
      // Redistribute if under and capacity exists
      const target = Math.min(totalSize, total);
      while (current < target) {
        let increased = false;
        for (const [k, c] of entries.sort((a, b) => b[1] - a[1])) {
          if (current >= target) break;
          const have = base.get(k) || 0;
          if (have < c) {
            base.set(k, have + 1);
            current += 1;
            increased = true;
          }
        }
        if (!increased) break;
      }
      return Object.fromEntries(base.entries());
    }

    function distribution(rows, fields) {
      if (!fields.length || !rows.length) return [];
      const counts = {};
      for (const row of rows) {
        const key = normalizeKey(fields.map(f => row[f]));
        counts[key] = (counts[key] || 0) + 1;
      }
      const total = rows.length;
      return Object.entries(counts).map(([key, count]) => {
      const values = JSON.parse(key).map(v => v === MISSING_VALUE ? null : v);
        const stratum = {};
        fields.forEach((f, i) => stratum[f] = values[i]);
        return { stratum, count, share: count / total };
      });
    }

    function numericColumns(rows, columns) {
      return columns.filter(col => rows.some(r => typeof r[col] === 'number' && Number.isFinite(r[col])));
    }

    function isIdentifierColumn(name, values) {
      const lower = name.toLowerCase();
      const idLike = /(id|identifier|gci|guid|uuid|code)$/i.test(lower);
      const numericValues = values.filter(v => typeof v === 'number' && Number.isFinite(v));
      const uniqueRatio = numericValues.length ? new Set(numericValues).size / numericValues.length : 0;
      const highCardinality = numericValues.length > 10 && uniqueRatio > 0.9;
      return idLike || highCardinality;
    }

    function summarizeNumericColumns(rows, columns) {
      const summaries = [];
      const numeric = numericColumns(rows, columns);
      for (const col of numeric) {
        const vals = rows.map(r => r[col]).filter(v => typeof v === 'number' && Number.isFinite(v));
        if (!vals.length) continue;
        if (isIdentifierColumn(col, vals)) continue;
        const sorted = vals.slice().sort((a, b) => a - b);
        const min = sorted[0];
        const max = sorted[sorted.length - 1];
        const mean = vals.reduce((s, v) => s + v, 0) / vals.length;
        const mid = Math.floor(sorted.length / 2);
        const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        summaries.push({ column: col, count: vals.length, min, max, mean, median });
      }
      return summaries.slice(0, 4);
    }

    function renderStats() {
      const pane = document.getElementById('statsPane');
      if (!pane) return;
      if (!state.summary) {
        pane.textContent = 'Run sampling to see summary statistics.';
        return;
      }
      const cfg = state.lastConfig || readConfigForm();
      const pop = {
        rows: state.population.length,
        numeric: summarizeNumericColumns(state.population, state.columns),
      };
      const sample = {
        rows: state.sample.length,
        numeric: summarizeNumericColumns(state.sample, state.columns),
        share: state.population.length ? state.sample.length / state.population.length : 0,
      };

      const formatNumber = (n, digits = 2) => Number.isFinite(n) ? n.toLocaleString(undefined, { maximumFractionDigits: digits }) : '-';
      const formatValue = (v) => {
        if (v === null || v === undefined) return 'n/a';
        if (v === '') return '(blank)';
        return String(v);
      };

      const renderStatPills = (summary) => {
        if (!summary.numeric.length) {
          return `<div class="stat-muted">No numeric columns detected (identifier-like columns are skipped).</div>`;
        }
        return summary.numeric.map(stat => `
          <span class="stat-pill">
            <strong>${stat.column}</strong> - mean=${formatNumber(stat.mean)} - p50=${formatNumber(stat.median)} - min=${formatNumber(stat.min)} - max=${formatNumber(stat.max)}
          </span>
        `).join('');
      };

      pane.innerHTML = `
        <div class="stats-grid">
          <div class="stats-card">
            <h3>Population</h3>
            <div class="stat-row">
              <span class="stat-pill"><strong>Rows</strong>: ${pop.rows.toLocaleString()}</span>
              <span class="stat-pill"><strong>Columns</strong>: ${state.columns.length}</span>
            </div>
            <div class="stat-row">${renderStatPills(pop)}</div>
          </div>
          <div class="stats-card">
            <h3>Sample</h3>
            <div class="stat-row">
              <span class="stat-pill"><strong>Rows</strong>: ${sample.rows.toLocaleString()}</span>
              <span class="stat-pill"><strong>Share</strong>: ${formatNumber(sample.share * 100)}%</span>
            </div>
            <div class="stat-row">${renderStatPills(sample)}</div>
          </div>
        </div>
        ${state.summary.stratify_fields && state.summary.stratify_fields.length ? `
        <div class="stats-card strata-card">
          <div class="stat-row">
            <span class="stat-pill"><strong>Stratified distribution</strong></span>
            <span class="stat-pill">Fields: ${state.summary.stratify_fields.join(', ')}</span>
          </div>
          <div class="table-wrap">
            <table class="table-zebra strata-table">
              <thead>
                <tr>
                  ${state.summary.stratify_fields.map(f => `<th>${f}</th>`).join('')}
                  <th>Population</th>
                  <th>Pop %</th>
                  <th>Sample</th>
                  <th>Sample %</th>
                </tr>
              </thead>
              <tbody>
                ${(() => {
                  const allocations = (state.summary.allocations || []).slice().sort((a, b) => (b.population_count ?? 0) - (a.population_count ?? 0));
                  if (!allocations.length) {
                    return `<tr><td colspan="${state.summary.stratify_fields.length + 4}" class="stat-muted">No stratification distribution available.</td></tr>`;
                  }
                  return allocations.map(a => {
                    const cells = state.summary.stratify_fields.map(f => `<td>${formatValue((a.stratum || {})[f])}</td>`).join('');
                    const popCount = a.population_count ?? 0;
                    const sampleCount = a.sample_count ?? 0;
                    return `
                      <tr>
                        ${cells}
                        <td>${popCount.toLocaleString()}</td>
                        <td>${formatNumber((a.share_of_population ?? 0) * 100)}%</td>
                        <td>${sampleCount.toLocaleString()}</td>
                        <td>${formatNumber((a.share_of_sample ?? 0) * 100)}%</td>
                      </tr>
                    `;
                  }).join('');
                })()}
              </tbody>
            </table>
          </div>
        </div>
        ` : ''}
        <div class="stat-muted">Identifier-like numeric fields (e.g., IDs/GCI) are excluded. Up to four numeric columns are summarized. Stats update when you regenerate the sample.</div>
      `;
      if (overrideNoteEl) {
        const justification = cfg.overrideJustification || '';
        const overrideActive = hasOverrides(cfg);
        if (overrideActive && justification) {
          overrideNoteEl.textContent = `Override justification: ${justification}`;
        }
      }
    }
    function configSignature(cfg) {
      return JSON.stringify({
        method: cfg.method,
        confidence: cfg.confidence,
        margin: cfg.margin,
        expectedErrorRate: cfg.expectedErrorRate,
        sampleSize: cfg.sampleSize,
        samplePercentage: cfg.samplePercentage,
        systematicStep: cfg.systematicStep,
        stratifyFields: cfg.stratifyFields,
      });
    }

    function computePlan(population, cfg) {
      const popSize = state.population.length;
      const overridePop = populationOverrideInput && populationOverrideInput.value ? parseInt(populationOverrideInput.value, 10) : null;
      const effectivePop = Number.isFinite(overridePop) && overridePop > 0 ? overridePop : popSize;
      const desiredSize = resolveSampleSize(effectivePop, cfg);
      if (desiredSize <= 0) throw new Error('Calculated sample size is 0. Adjust parameters.');
      if (!cfg.stratifyFields.length) {
        return {
          allocations: [
            {
              key: '__all__',
              stratum: {},
              population_count: effectivePop,
              sample_count: Math.min(effectivePop, desiredSize),
            },
          ],
          plannedSize: Math.min(effectivePop, desiredSize),
          desiredSize,
          stratifyFields: [],
          coverageOverrides: [],
        };
      }
      const groups = {};
      for (const row of population) {
        const key = normalizeKey(cfg.stratifyFields.map(f => row[f]));
        if (!groups[key]) groups[key] = [];
        groups[key].push(row);
      }
      const counts = Object.fromEntries(Object.entries(groups).map(([k, arr]) => [k, arr.length]));
      const allocationsMap = proportionalAllocation(counts, desiredSize);

      const allocations = Object.entries(groups).map(([k, arr]) => {
        const values = JSON.parse(k).map(v => v === MISSING_VALUE ? null : v);
        const stratum = {};
        cfg.stratifyFields.forEach((f, i) => stratum[f] = values[i]);
        const sampleCount = allocationsMap[k] || 0;

        return {
          key: k,
          stratum,
          population_count: arr.length,
          sample_count: sampleCount,
          proportional_allocation: sampleCount, // Store original proportional allocation for tracking differences
        };
      });
      const plannedSize = allocations.reduce((s, a) => s + a.sample_count, 0);
      return {
        allocations,
        plannedSize,
        desiredSize,
        stratifyFields: cfg.stratifyFields.slice(),
        populationSize: population.length,
        signature: configSignature(cfg),
        coverageOverrides: [],
      };
    }

    function renderPlan() {
      if (!state.plan) {
        planBox.innerHTML = 'Load data and click "Plan sample" to see per-stratum counts.';
        return;
      }
      // Count strata with zero samples that have population > 0
      const zeroStrata = state.plan.allocations.filter(a => a.sample_count === 0 && a.population_count > 0);
      const zeroStrataCount = zeroStrata.length;
      const coverageOverrideCount = state.plan.coverageOverrides ? state.plan.coverageOverrides.length : 0;

      const rowsHtml = state.plan.allocations.map((a, idx) => {
        const label = Object.entries(a.stratum).map(([k, v]) => `${k}: ${v === null ? 'NULL' : v}`).join(', ') || '(all)';
        const encodedKey = encodeURIComponent(a.key);
        const isOverridden = state.plan.coverageOverrides && state.plan.coverageOverrides.some(o => JSON.stringify(o.stratum) === JSON.stringify(a.stratum));
        const overrideTag = isOverridden ? ' <span style="color:var(--accent-2);font-size:11px;" title="Coverage override applied">(+1 override)</span>' : '';
        const isZero = a.sample_count === 0 && a.population_count > 0;
        return `
          <tr${isOverridden ? ' style="background:rgba(245,158,11,0.08);"' : (isZero ? ' style="background:rgba(220,38,38,0.06);"' : '')}>
            <td>${idx + 1}</td>
            <td>${label}${overrideTag}</td>
            <td>${a.population_count}</td>
            <td><input type="number" min="0" max="${a.population_count}" value="${a.sample_count}" data-plan-key="${encodedKey}"></td>
          </tr>
        `;
      }).join('');
      const total = state.plan.allocations.reduce((s, a) => s + a.sample_count, 0);
      state.plan.plannedSize = total;
      const match = total === state.plan.desiredSize;
      const zeroStrataNote = zeroStrataCount > 0 ? `<div class="badge pill badge-warn">${zeroStrataCount} stratum/strata with 0 samples</div>` : '';
      const coverageOverrideNote = coverageOverrideCount > 0 ? `<div class="badge pill badge-ok">${coverageOverrideCount} coverage override(s) applied</div>` : '';
      const addCoverageBtn = zeroStrataCount > 0 ? `<button type="button" id="addCoverageBtn" class="secondary" style="margin-left:8px;">Add +1 to zero strata</button>` : '';
      planBox.innerHTML = `
        <div class="badge pill ${match ? 'badge-ok' : 'badge-warn'}">Planned total: ${total}</div>
        <div class="badge pill">Calculated target: ${state.plan.desiredSize}</div>
        ${zeroStrataNote}
        ${coverageOverrideNote}
        ${addCoverageBtn}
        <div class="plan-scroll">
          <table class="table-zebra">
            <thead>
              <tr><th>#</th><th>Stratum</th><th>Population</th><th>Sample count</th></tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
        <div class="hint">${match ? 'Adjust sample counts per stratum if needed, then click "Generate sample".' : 'Totals differ from target - adjust counts or proceed if override is intended.'}${zeroStrataCount > 0 ? ' Click "Add +1 to zero strata" to ensure coverage across all observed strata.' : ''}</div>
      `;

      // Add event listener for coverage button
      const addCoverageBtnEl = document.getElementById('addCoverageBtn');
      if (addCoverageBtnEl) {
        addCoverageBtnEl.addEventListener('click', () => {
          const overrides = [];
          for (const alloc of state.plan.allocations) {
            if (alloc.sample_count === 0 && alloc.population_count > 0) {
              overrides.push({
                stratum: { ...alloc.stratum },
                original_sample_count: 0,
                adjusted_to: 1,
                justification: 'Override made to allow for sampling coverage across all observed strata in the population',
              });
              alloc.sample_count = 1;
            }
          }
          state.plan.coverageOverrides = (state.plan.coverageOverrides || []).concat(overrides);
          renderPlan();
        });
      }

      planBox.querySelectorAll('input[type="number"]').forEach(input => {
        input.addEventListener('input', (e) => {
          const encoded = e.target.getAttribute('data-plan-key') || '';
          const key = decodeURIComponent(encoded);
          const val = Math.max(0, parseInt(e.target.value || '0', 10));
          const alloc = state.plan.allocations.find(a => a.key === key);
          if (!alloc) return;
          alloc.sample_count = Math.min(alloc.population_count, val);
          renderPlan();
        });
      });
      runBtn.disabled = total <= 0;
    }

    function stratifiedSample(rows, cfg, rng, desiredSize, allocationOverrides = null) {
      const fields = cfg.stratifyFields;
      const overridePop = populationOverrideInput && populationOverrideInput.value ? parseInt(populationOverrideInput.value, 10) : null;
      const effectivePop = Number.isFinite(overridePop) && overridePop > 0 ? overridePop : rows.length;
      const totalSize = desiredSize ?? resolveSampleSize(effectivePop, cfg);
      if (totalSize <= 0) return { sample: [], allocations: [] };

      const groups = {};
      for (const row of rows) {
        const key = normalizeKey(fields.map(f => row[f]));
        if (!groups[key]) groups[key] = [];
        groups[key].push(row);
      }
      const counts = Object.fromEntries(Object.entries(groups).map(([k, arr]) => [k, arr.length]));
      const allocations = allocationOverrides || proportionalAllocation(counts, totalSize);
      const actualTotal = Object.values(allocations).reduce((s, v) => s + v, 0);

      const samples = [];
      const allocationSummary = [];
      for (const [key, groupRows] of Object.entries(groups)) {
        const alloc = allocations[key] || 0;
        if (alloc <= 0) continue;
        let chosen = [];
        if (cfg.method === 'systematic') {
          chosen = systematicSample(groupRows, alloc, cfg.systematicRandomStart, rng);
        } else {
          chosen = randomSample(groupRows, alloc, rng);
        }
      const values = JSON.parse(key).map(v => v === MISSING_VALUE ? null : v);
        const stratum = {};
        fields.forEach((f, i) => stratum[f] = values[i]);
        allocationSummary.push({
          stratum,
          population_count: groupRows.length,
          sample_count: chosen.length,
          share_of_population: groupRows.length / rows.length,
          share_of_sample: chosen.length / (actualTotal || 1),
        });
        samples.push(...chosen);
      }
      return { sample: samples, allocations: allocationSummary };
    }

    function buildSummary(population, sample, allocations, cfg, plannedSize, plan) {
      const coverageOverrides = plan && plan.coverageOverrides ? plan.coverageOverrides : [];
      const planAllocations = plan && plan.allocations ? plan.allocations : [];

      // Build allocations with difference tracking
      const allocationsWithDiff = allocations.map(alloc => {
        // Find matching plan allocation to get proportional allocation
        const planAlloc = planAllocations.find(p => JSON.stringify(p.stratum) === JSON.stringify(alloc.stratum));
        const proportionalAllocation = planAlloc ? planAlloc.proportional_allocation : alloc.sample_count;
        const allocationDifference = alloc.sample_count - proportionalAllocation;

        return {
          ...alloc,
          proportional_allocation: proportionalAllocation,
          allocation_difference: allocationDifference,
        };
      });

      // Build consolidated overrides section
      const overridePop = populationOverrideInput && populationOverrideInput.value ? parseInt(populationOverrideInput.value, 10) : null;
      const hasPopulationOverride = Number.isFinite(overridePop) && overridePop > 0;
      const hasSampleSizeOverride = cfg.sampleSize != null;
      const hasSamplePercentageOverride = cfg.samplePercentage != null;
      const hasSystematicStepOverride = cfg.systematicStep != null;

      // Calculate allocation adjustments first so we can check if any exist
      const allocationAdjustments = allocationsWithDiff.filter(a => a.allocation_difference !== 0).map(a => ({
        stratum: a.stratum,
        proportional_allocation: a.proportional_allocation,
        actual_allocation: a.sample_count,
        difference: a.allocation_difference,
      }));

      // Include allocation adjustments in the override check
      const hasAnyOverride = hasPopulationOverride || hasSampleSizeOverride || hasSamplePercentageOverride || hasSystematicStepOverride || coverageOverrides.length > 0 || allocationAdjustments.length > 0;

      const overridesSection = {
        has_overrides: hasAnyOverride,
        justification: cfg.overrideJustification || null,
        parameter_overrides: {
          population_size: hasPopulationOverride ? { applied: true, value: overridePop, original: population.length } : { applied: false },
          sample_size: hasSampleSizeOverride ? { applied: true, value: cfg.sampleSize } : { applied: false },
          sample_percentage: hasSamplePercentageOverride ? { applied: true, value: cfg.samplePercentage } : { applied: false },
          systematic_step: hasSystematicStepOverride ? { applied: true, value: cfg.systematicStep } : { applied: false },
        },
        coverage_overrides: coverageOverrides.length > 0 ? coverageOverrides : [],
        allocation_adjustments: allocationAdjustments,
      };

      return {
        generated_at_utc: new Date().toISOString(),
        methodology: {
          method: cfg.method,
          confidence: cfg.confidence,
          margin: cfg.margin,
          expected_error_rate: cfg.expectedErrorRate,
          seed: cfg.seed,
          systematic_random_start: cfg.systematicRandomStart,
          planned_sample_size: plannedSize,
        },
        stratify_fields: cfg.stratifyFields,
        source: {
          file_name: state.fileName,
          sheet_name: state.sheetName,
        },
        population: {
          size: population.length,
          distribution: distribution(population, cfg.stratifyFields),
        },
        sample: {
          size: sample.length,
          distribution: distribution(sample, cfg.stratifyFields),
        },
        allocations: allocationsWithDiff,
        overrides: overridesSection,
        sample_ids: cfg.idColumn ? sample.map(r => r[cfg.idColumn]) : undefined,
      };
    }

    function sampleData(population, cfg, plan) {
      const desiredSize = plan ? plan.allocations.reduce((s, a) => s + a.sample_count, 0) : resolveSampleSize(population.length, cfg);
      if (desiredSize <= 0 && population.length > 0) throw new Error('Calculated sample size is 0. Adjust parameters.');

      const rng = rngFactory(cfg.seed ?? 42);
      let sample = [];
      let allocations = [];
      if (cfg.stratifyFields.length) {
        const overrideMap = plan ? Object.fromEntries(plan.allocations.map(a => [a.key, a.sample_count])) : null;
        ({ sample, allocations } = stratifiedSample(population, cfg, rng, desiredSize, overrideMap));
      } else {
        const take = plan ? Math.min(desiredSize, population.length) : desiredSize;
        if (cfg.method === 'systematic') {
          sample = systematicSample(population, take, cfg.systematicRandomStart, rng);
        } else {
          sample = randomSample(population, take, rng);
        }
        allocations = plan ? [
          {
            stratum: {},
            population_count: population.length,
            sample_count: sample.length,
            share_of_population: 1,
            share_of_sample: 1,
          },
        ] : [];
      }
      const summary = buildSummary(population, sample, allocations, cfg, desiredSize, plan);
      return { sample, summary };
    }

    function toCsv(rows, columns) {
      const escape = (v) => {
        if (v === null || v === undefined) return '';
        const s = String(v).replace(/"/g, '""');
        return /[",\n]/.test(s) ? `"${s}"` : s;
      };
      const header = columns.join(',');
      const lines = rows.map(r => columns.map(c => escape(r[c])).join(','));
      return [header, ...lines].join('\r\n');
    }

    function renderSummary() {
      if (!state.summary) {
        summaryBox.textContent = 'Load data and run sampling to see results.';
        if (overrideNoteEl) overrideNoteEl.textContent = '';
        downloadCsvBtn.disabled = true;
        downloadJsonBtn.disabled = true;
        if (genSummaryBtn) genSummaryBtn.disabled = true;
        if (aiSummaryTextEl) aiSummaryTextEl.value = '';
        state.report = '';
        renderStats();
        updateStatusBar();
        return;
      }
      if (genSummaryBtn) genSummaryBtn.disabled = false;
      const cfg = state.lastConfig || readConfigForm();
      const s = state.summary;
      const lines = [];
      lines.push(`Selected ${s.sample.size} of ${s.population.size} using "${s.methodology.method}". Planned size: ${s.methodology.planned_sample_size}.`);
      if (s.stratify_fields && s.stratify_fields.length) {
        lines.push(`Stratified by: ${s.stratify_fields.join(', ')}`);
      }
      if (s.allocations && s.allocations.length) {
        lines.push('');
        lines.push('Per-stratum sample counts:');
        s.allocations.forEach(a => {
          const desc = Object.entries(a.stratum || {}).map(([k, v]) => `${k}=${v === null ? 'NULL' : v}`).join(', ');
          lines.push(`- ${desc}: ${a.sample_count} of ${a.population_count} (${(a.share_of_sample * 100).toFixed(1)}% of sample)`);
        });
      }
      summaryBox.textContent = lines.join('\n');
      if (overrideNoteEl) {
        const justification = cfg.overrideJustification || '';
        const overrideActive = hasOverrides(cfg);
        overrideNoteEl.textContent = overrideActive && justification ? `Override justification: ${justification}` : '';
      }
      downloadCsvBtn.disabled = false;
      downloadJsonBtn.disabled = false;
      renderStats();
      updateStatusBar();
    }

    function readConfigForm() {
      const form = document.getElementById('configForm');
      const method = form.method.value;
      let confidence = parseFloat(form.confidence.value);
      if (!Number.isFinite(confidence)) confidence = 99;
      if (confidence >= 1) confidence = confidence / 100; // percent-style input
      confidence = Math.max(0.001, Math.min(0.999, confidence));
      const rawMargin = parseFloat(form.margin.value);
      let margin = rawMargin;
      if (!Number.isFinite(margin)) margin = 5;
      if (margin >= 1) {
        margin = margin / 100; // percent input
      }
      margin = Math.max(0.0001, Math.min(1, margin));

      let expectedError = parseFloat(form.expectedError.value);
      if (!Number.isFinite(expectedError)) expectedError = 1;
      if (expectedError >= 1) expectedError = expectedError / 100; // percent input
      expectedError = Math.max(0, Math.min(1, expectedError));
      const sampleSizeVal = form.sampleSize.value.trim();
      const samplePctVal = form.samplePct.value.trim();
      const stepVal = form.systematicStep.value.trim();
      const stratifyFields = state.stratifySelected.slice();
      const seed = parseInt(form.seed.value, 10);
      const randomStart = form.randomStart.value === 'yes';
      const idRaw = (idColumnInput.value || '').trim();
      const idColumn = state.columns.includes(idRaw) ? idRaw : null;
      const overrideJustification = overrideJustificationEl ? (overrideJustificationEl.value || '').trim() : '';

      return {
        method,
        confidence,
        margin,
        expectedErrorRate: expectedError,
        sampleSize: sampleSizeVal === '' ? null : parseInt(sampleSizeVal, 10),
        samplePercentage: samplePctVal === '' ? null : parseFloat(samplePctVal),
        systematicStep: stepVal === '' ? null : parseInt(stepVal, 10),
        stratifyFields,
        seed: Number.isFinite(seed) ? seed : 42,
        systematicRandomStart: randomStart,
        idColumn,
        overrideJustification,
      };
    }

    function hasOverrides(cfg) {
      return Boolean(
        (cfg.sampleSize != null) ||
        (cfg.samplePercentage != null) ||
        (cfg.systematicStep != null) ||
        (populationOverrideInput && populationOverrideInput.value)
      );
    }

    function ensureJustification(cfg, messageTarget) {
      if (hasOverrides(cfg) && !cfg.overrideJustification) {
        const msg = 'Override justification is required when overrides are used.';
        if (messageTarget) messageTarget.textContent = msg;
        setStatus(msg, 'danger');
        if (overrideJustificationEl) overrideJustificationEl.focus();
        return false;
      }
      return true;
    }

    function updateJustificationVisibility() {
      const cfg = readConfigForm();
      const show = hasOverrides(cfg);
      if (overrideJustificationWrapper) {
        overrideJustificationWrapper.style.display = show ? 'block' : 'none';
      }
      if (!show && overrideNoteEl) {
        overrideNoteEl.textContent = '';
      }
    }

    function autosizeTextarea(el) {
      if (!el) return;
      el.style.height = 'auto';
      el.style.height = `${el.scrollHeight}px`;
    }

    function resetAll() {
      state.population = [];
      state.columns = [];
      state.sample = [];
      state.summary = null;
      state.sheetName = null;
      state.fileName = null;
      state.plan = null;
      state.report = '';
      state.fileMeta = null;
      state.stratifySelected = [];
      idColumnInput.value = '';
      fileInput.value = '';
      if (aiSummaryTextEl) aiSummaryTextEl.value = '';
      if (genSummaryBtn) genSummaryBtn.disabled = true;
      if (summaryStatusEl) summaryStatusEl.textContent = '';
      renderColumns();
      renderStratifyOptions();
      renderSummary();
      renderPlan();
      planBtn.disabled = true;
      runBtn.disabled = true;
      sheetNameHint.textContent = '';
      setStatus('Reset. Load a new file.', 'muted');
      renderStats();
      renderFileMeta();
      updateStatusBar();
    }

    planBtn.addEventListener('click', () => {
      if (!state.population.length) {
        setStatus('Load an Excel file first.', 'danger');
        return;
      }
      try {
        const cfg = readConfigForm();
        const plan = computePlan(state.population, cfg);
        plan.populationSize = state.population.length;
        state.plan = plan;
        renderPlan();
        runBtn.disabled = plan.plannedSize <= 0;
        setStatus(`Plan ready. Planned sample size: ${plan.plannedSize}. Adjust allocations if needed, then generate.`, 'success');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Planning failed.', 'danger');
      }
    });

    document.getElementById('configForm').addEventListener('submit', (e) => {
      e.preventDefault();
      if (!state.population.length) {
        setStatus('Load an Excel file first.', 'danger');
        return;
      }
      try {
      const cfg = readConfigForm();
      const fieldsKey = JSON.stringify(cfg.stratifyFields || []);
      state.lastConfig = cfg;
      if (!state.plan || state.plan.populationSize !== state.population.length || JSON.stringify(state.plan.stratifyFields || []) !== fieldsKey || state.plan.signature !== configSignature(cfg)) {
        const plan = computePlan(state.population, cfg);
        plan.populationSize = state.population.length;
        state.plan = plan;
        renderPlan();
      }
        const { sample, summary } = sampleData(state.population, cfg, state.plan);
        state.sample = sample;
        state.summary = summary;
        renderSummary();
        setStatus(`Sample created: ${sample.length} records.`, 'success');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Sampling failed.', 'danger');
      }
    });

    if (stratifySelect) {
      const addStratifyField = () => {
        const val = (stratifySelect.value || '').trim();
        if (!val) return;
        if (!state.columns.includes(val)) {
          setStatus('Select a column from the list to stratify.', 'danger');
          return;
        }
        setStratifySelection(val, true);
        runBtn.disabled = true;
        stratifySelect.value = '';
      };
      stratifySelect.addEventListener('change', addStratifyField);
      stratifySelect.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          addStratifyField();
        }
      });
    }

    resetBtn.addEventListener('click', resetAll);

    // Show/hide justification when override fields change
    ['sampleSize','samplePct','systematicStep','populationOverride'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('input', updateJustificationVisibility);
    });
    if (overrideJustificationEl) {
      overrideJustificationEl.addEventListener('input', () => autosizeTextarea(overrideJustificationEl));
      autosizeTextarea(overrideJustificationEl);
    }

    downloadCsvBtn.addEventListener('click', () => {
      if (!state.sample.length) return;
      const cfg = state.lastConfig || readConfigForm();
      if (!ensureJustification(cfg, statusEl)) return;
      const csv = '\ufeff' + toCsv(state.sample, state.columns); // BOM to help Excel detect UTF-8
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sample.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    downloadJsonBtn.addEventListener('click', () => {
      if (!state.summary) return;
      const cfg = state.lastConfig || readConfigForm();
      if (!ensureJustification(cfg, statusEl)) return;
      const blob = new Blob([JSON.stringify(state.summary, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sampling_summary.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    // AI Summary generation
    async function generateAISummary() {
      if (!state.summary) {
        if (summaryStatusEl) {
          summaryStatusEl.textContent = 'Generate a sample first before creating an AI summary.';
          summaryStatusEl.style.color = 'var(--danger)';
        }
        return;
      }
      if (genSummaryBtn) genSummaryBtn.disabled = true;
      if (summaryStatusEl) {
        summaryStatusEl.textContent = 'Generating AI summary... This may take a moment.';
        summaryStatusEl.style.color = 'var(--muted)';
      }
      if (aiSummaryTextEl) aiSummaryTextEl.value = '';

      try {
        const resp = await fetch(REPORT_FUNCTION_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ summary: state.summary }),
        });

        if (!resp.ok) {
          const errText = await resp.text();
          throw new Error(errText || `Request failed with status ${resp.status}`);
        }

        const data = await resp.json();
        const report = data.report || '';
        state.report = report;

        if (aiSummaryTextEl) aiSummaryTextEl.value = report;
        if (summaryStatusEl) {
          summaryStatusEl.textContent = 'AI summary generated successfully.';
          summaryStatusEl.style.color = 'var(--success)';
          setTimeout(() => { summaryStatusEl.textContent = ''; }, 5000);
        }
      } catch (err) {
        console.error('AI summary generation failed:', err);
        if (summaryStatusEl) {
          summaryStatusEl.textContent = `Failed to generate summary: ${err.message}`;
          summaryStatusEl.style.color = 'var(--danger)';
        }
      } finally {
        if (genSummaryBtn && state.summary) genSummaryBtn.disabled = false;
      }
    }

    if (genSummaryBtn) {
      genSummaryBtn.addEventListener('click', generateAISummary);
    }
    if (editRandomizerToggle && randomizerSection) {
      editRandomizerToggle.addEventListener('change', () => {
        randomizerSection.style.display = editRandomizerToggle.checked ? 'grid' : 'none';
      });
    }

    setupDropzone();
    renderRecentUploads();
    renderFileMeta();
    renderSummary();
    renderPlan();
    planBtn.disabled = true;
    runBtn.disabled = true;
    setStatus('Ready. Load an Excel file to begin.');
  </script>
</body>
</html>
