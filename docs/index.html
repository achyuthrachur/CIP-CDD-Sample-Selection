<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CIP / CDD Sample Selection</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>
  <style>
    :root {
      --bg: #f6f7fb;
      --panel: #ffffff;
      --accent: #2f80ed;
      --accent-2: #ec6f66;
      --muted: #5f6c7b;
      --text: #1f2a3d;
      --success: #1aa36f;
      --danger: #d64545;
      --border: #e1e6ef;
      --pill: #f0f3f9;
      --shadow: 0 20px 60px rgba(31,42,61,0.12);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Space Grotesk', system-ui, -apple-system, sans-serif;
      background:
        radial-gradient(circle at 15% 15%, rgba(47,128,237,0.08), transparent 25%),
        radial-gradient(circle at 80% 0%, rgba(236,111,102,0.12), transparent 30%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    a { color: var(--accent); }
    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 20px 48px;
      display: grid;
      gap: 18px;
    }
    header h1 {
      margin: 0 0 4px 0;
      font-weight: 600;
      letter-spacing: -0.4px;
    }
    header p {
      margin: 0;
      color: var(--muted);
    }
    .grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      box-shadow: var(--shadow);
    }
    .panel h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
      font-weight: 600;
    }
    .muted { color: var(--muted); }
    .dropzone {
      border: 1px dashed #cbd5e5;
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      background: #f9fbff;
    }
    .dropzone.dragging {
      border-color: var(--accent);
      background: rgba(47,128,237,0.08);
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: var(--pill);
      color: var(--text);
      font-size: 12px;
      margin: 4px 4px 4px 0;
      border: 1px solid var(--border);
    }
    label {
      display: block;
      font-weight: 500;
      margin: 12px 0 6px;
    }
    input[type="number"],
    select,
    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #fdfdff;
      color: var(--text);
      font-size: 14px;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .checkboxes label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin: 0;
      font-weight: 500;
      padding: 8px 10px;
      background: var(--pill);
      border-radius: 10px;
      border: 1px solid var(--border);
      cursor: pointer;
    }
    .checkboxes input {
      accent-color: var(--accent);
    }
    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 14px;
    }
    button {
      border: none;
      border-radius: 10px;
      padding: 11px 14px;
      font-weight: 600;
      cursor: pointer;
      color: #ffffff;
      background: linear-gradient(135deg, var(--accent), #4da1ff);
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.2s;
      box-shadow: 0 10px 25px rgba(47,128,237,0.25);
    }
    button.secondary {
      background: #f4f6fb;
      color: var(--text);
      box-shadow: none;
      border: 1px solid var(--border);
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .pill-success { border-color: rgba(92,225,166,0.3); color: var(--success); }
    .pill-danger { border-color: rgba(255,140,140,0.3); color: var(--danger); }
    .summary {
      background: #f7f9fc;
      border-radius: 12px;
      padding: 14px;
      border: 1px solid var(--border);
      max-height: 320px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: 'Space Grotesk', system-ui, -apple-system, sans-serif;
      color: var(--text);
      line-height: 1.5;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 10px;
      background: #1b212d;
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      margin-right: 8px;
    }
    .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>CIP / CDD Sample Selection</h1>
      <p class="muted">Client-side Excel sampling with statistical defaults (99% / 5% / 1%). Drag and drop your file to begin.</p>
    </header>

    <div class="grid">
      <section class="panel">
        <h2>1) Load your Excel</h2>
        <div id="dropzone" class="dropzone">
          <strong>Drag & drop</strong> an Excel file (.xlsx, .xls, .xlsm, .xlsb)<br>
          or <label for="fileInput" style="color: var(--accent); cursor: pointer; text-decoration: underline;">browse</label>
          <div class="hint" id="sheetNameHint"></div>
        </div>
        <input id="fileInput" type="file" accept=".xlsx,.xls,.xlsm,.xlsb" style="display:none" />
        <div id="columns" style="margin-top:12px;"></div>
        <div id="populationMeta" class="hint"></div>
      </section>

      <section class="panel">
        <h2>2) Configure sampling</h2>
        <form id="configForm">
          <label for="method">Method</label>
          <select id="method" name="method">
            <option value="statistical" selected>Statistical (default)</option>
            <option value="simple_random">Simple random</option>
            <option value="percentage">Percentage of population</option>
            <option value="systematic">Systematic</option>
          </select>

          <div class="row">
            <div>
              <label for="confidence">Confidence</label>
              <input type="number" step="0.001" id="confidence" name="confidence" value="0.99" min="0.5" max="0.9999">
            </div>
            <div>
              <label for="margin">Margin of error</label>
              <input type="number" step="0.001" id="margin" name="margin" value="0.05" min="0.0001" max="0.5">
            </div>
            <div>
              <label for="expectedError">Expected error rate</label>
              <input type="number" step="0.001" id="expectedError" name="expectedError" value="0.01" min="0" max="0.5">
            </div>
          </div>

          <div class="row">
            <div>
              <label for="sampleSize">Sample size (optional)</label>
              <input type="number" id="sampleSize" name="sampleSize" placeholder="auto">
              <div class="hint">Use for simple random/systematic, or override.</div>
            </div>
            <div>
              <label for="samplePct">Sample % (optional)</label>
              <input type="number" id="samplePct" name="samplePct" placeholder="e.g. 10">
              <div class="hint">Use with percentage/simple_random/systematic.</div>
            </div>
            <div>
              <label for="systematicStep">Systematic step (optional)</label>
              <input type="number" id="systematicStep" name="systematicStep" placeholder="auto">
            </div>
          </div>

          <label>Stratify by</label>
          <div id="stratifyOptions" class="checkboxes muted">Load a file to pick columns.</div>

          <label for="idColumn">ID column (optional)</label>
          <select id="idColumn" name="idColumn">
            <option value="">(none)</option>
          </select>

          <div class="row">
            <div>
              <label for="seed">Random seed</label>
              <input type="number" id="seed" name="seed" value="42">
            </div>
            <div>
              <label for="randomStart">Systematic random start</label>
              <select id="randomStart" name="randomStart">
                <option value="yes" selected>Yes (default)</option>
                <option value="no">No</option>
              </select>
            </div>
          </div>

          <div class="buttons">
            <button type="submit" id="runBtn" disabled>Generate sample</button>
            <button type="button" class="secondary" id="resetBtn">Reset</button>
          </div>
          <div class="hint" id="status"></div>
        </form>
      </section>

      <section class="panel">
        <h2>3) Review & download</h2>
        <div class="buttons">
          <button type="button" id="downloadCsv" disabled>Download sample CSV</button>
          <button type="button" class="secondary" id="downloadJson" disabled>Download JSON summary</button>
        </div>
        <div class="summary" id="summaryBox">Load data and run sampling to see results.</div>
      </section>
    </div>
  </main>

  <script>
    const MISSING_VALUE = "<MISSING>";
    const state = {
      population: [],
      columns: [],
      sample: [],
      summary: null,
      sheetName: null,
      fileName: null,
    };

    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const columnsEl = document.getElementById('columns');
    const stratifyOptionsEl = document.getElementById('stratifyOptions');
    const idColumnEl = document.getElementById('idColumn');
    const populationMetaEl = document.getElementById('populationMeta');
    const statusEl = document.getElementById('status');
    const summaryBox = document.getElementById('summaryBox');
    const sheetNameHint = document.getElementById('sheetNameHint');

    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const downloadCsvBtn = document.getElementById('downloadCsv');
    const downloadJsonBtn = document.getElementById('downloadJson');

    function setStatus(msg, tone = 'muted') {
      statusEl.textContent = msg;
      statusEl.style.color = tone === 'danger' ? 'var(--danger)' : tone === 'success' ? 'var(--success)' : 'var(--muted)';
    }

    function normalizeValue(value) {
      if (value === null || value === undefined || (typeof value === 'number' && Number.isNaN(value))) {
        return MISSING_VALUE;
      }
      return value;
    }

    function renderColumns() {
      if (!state.columns.length) {
        columnsEl.innerHTML = '';
        populationMetaEl.textContent = '';
        return;
      }
      columnsEl.innerHTML = state.columns.map(col => `<span class="pill">${col}</span>`).join('');
      populationMetaEl.textContent = `${state.population.length.toLocaleString()} records loaded${state.sheetName ? ` from sheet "${state.sheetName}"` : ''}.`;
    }

    function renderStratifyOptions() {
      if (!state.columns.length) {
        stratifyOptionsEl.classList.add('muted');
        stratifyOptionsEl.textContent = 'Load a file to pick columns.';
        return;
      }
      stratifyOptionsEl.classList.remove('muted');
      stratifyOptionsEl.innerHTML = state.columns.map(col => {
        return `<label><input type="checkbox" name="stratify" value="${col}"> ${col}</label>`;
      }).join('');

      idColumnEl.innerHTML = `<option value="">(none)</option>` + state.columns.map(col => `<option value="${col}">${col}</option>`).join('');
    }

    function handleFiles(files) {
      if (!files || !files.length) return;
      const file = files[0];
      state.fileName = file.name;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          state.sheetName = sheetName;
          const ws = workbook.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(ws, { defval: null });
          if (!json.length) {
            setStatus('Sheet is empty.', 'danger');
            return;
          }
          state.population = json;
          state.columns = Object.keys(json[0]);
          renderColumns();
          renderStratifyOptions();
          setStatus(`Loaded ${json.length} rows from ${sheetName}.`, 'success');
          runBtn.disabled = false;
          sheetNameHint.textContent = `Using first sheet: ${sheetName}`;
        } catch (err) {
          console.error(err);
          setStatus('Failed to read Excel file. Ensure it has a header row.', 'danger');
        }
      };
      reader.readAsArrayBuffer(file);
    }

    function setupDropzone() {
      ['dragenter', 'dragover'].forEach(evt => {
        dropzone.addEventListener(evt, e => {
          e.preventDefault();
          e.stopPropagation();
          dropzone.classList.add('dragging');
        });
      });
      ['dragleave', 'drop'].forEach(evt => {
        dropzone.addEventListener(evt, e => {
          e.preventDefault();
          e.stopPropagation();
          dropzone.classList.remove('dragging');
        });
      });
      dropzone.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
      dropzone.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', e => handleFiles(e.target.files));
    }

    function rngFactory(seed = 42) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = t;
        r = Math.imul(r ^ r >>> 15, r | 1);
        r ^= r + Math.imul(r ^ r >>> 7, r | 61);
        return ((r ^ r >>> 14) >>> 0) / 4294967296;
      };
    }

    function shuffle(arr, rng) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function randomSample(arr, size, rng) {
      if (size <= 0) return [];
      const take = Math.min(arr.length, size);
      return shuffle(arr, rng).slice(0, take);
    }

    function systematicSample(arr, size, randomStart, rng) {
      const n = arr.length;
      if (size <= 0) return [];
      if (size >= n) return arr.slice();
      const offset = randomStart ? Math.floor(rng() * Math.ceil(n / size)) : 0;
      const indices = [];
      for (let k = 0; k < size; k++) {
        const base = Math.floor((k * n) / size);
        indices.push((base + offset) % n);
      }
      return indices.map(i => arr[i]);
    }

    function zScore(confidence) {
      const c = Math.max(0.001, Math.min(0.999, confidence));
      try {
        return jStat.normal.inv(1 - (1 - c) / 2, 0, 1);
      } catch {
        // fallback common values
        if (Math.abs(c - 0.95) < 1e-3) return 1.96;
        if (Math.abs(c - 0.99) < 1e-3) return 2.576;
        if (Math.abs(c - 0.90) < 1e-3) return 1.645;
        return 2.576;
      }
    }

    function statisticalSampleSize(N, confidence, margin, expectedError) {
      if (N <= 0) return 0;
      if (!(margin > 0 && margin < 1)) throw new Error('Margin must be in (0,1).');
      if (!(expectedError >= 0 && expectedError <= 1)) throw new Error('Expected error rate must be in [0,1].');
      const z = zScore(confidence);
      const p = expectedError;
      const n0 = (z * z * p * (1 - p)) / (margin * margin);
      const n = n0 / (1 + (n0 - 1) / N);
      return Math.ceil(n);
    }

    function resolveSampleSize(N, cfg) {
      if (N <= 0) return 0;
      const method = cfg.method;
      let size = 0;
      if (method === 'statistical') {
        size = statisticalSampleSize(N, cfg.confidence, cfg.margin, cfg.expectedErrorRate);
      } else if (method === 'percentage') {
        if (cfg.samplePercentage == null) throw new Error('samplePercentage is required for percentage sampling.');
        size = Math.ceil(N * (cfg.samplePercentage / 100));
      } else if (method === 'simple_random') {
        if (cfg.sampleSize == null && cfg.samplePercentage == null) throw new Error('Provide sampleSize or samplePercentage for simple_random.');
        size = cfg.sampleSize != null ? cfg.sampleSize : Math.ceil(N * (cfg.samplePercentage / 100));
      } else if (method === 'systematic') {
        if (cfg.sampleSize != null) {
          size = cfg.sampleSize;
        } else if (cfg.samplePercentage != null) {
          size = Math.ceil(N * (cfg.samplePercentage / 100));
        } else {
          size = statisticalSampleSize(N, cfg.confidence, cfg.margin, cfg.expectedErrorRate);
        }
      } else {
        throw new Error(`Unsupported method ${method}`);
      }
      return Math.max(0, Math.min(N, Math.floor(size)));
    }

    function normalizeKey(values) {
      return JSON.stringify(values.map(v => normalizeValue(v)));
    }

    function proportionalAllocation(countsMap, totalSize) {
      const entries = Object.entries(countsMap);
      if (!entries.length || totalSize <= 0) return Object.fromEntries(entries.map(([k]) => [k, 0]));
      const total = entries.reduce((s, [, c]) => s + c, 0);
      const raw = entries.map(([k, c]) => [k, (c / total) * totalSize]);
      const base = new Map(raw.map(([k, v]) => [k, Math.floor(v)]));
      let remainder = totalSize - Array.from(base.values()).reduce((s, v) => s + v, 0);
      if (remainder > 0) {
        const fractional = raw.map(([k, v]) => [k, v - Math.floor(v)]).sort((a, b) => b[1] - a[1]);
        for (let i = 0; i < fractional.length && remainder > 0; i++, remainder--) {
          const key = fractional[i][0];
          base.set(key, (base.get(key) || 0) + 1);
        }
      }
      // Ensure at least one per stratum when possible
      if (totalSize >= entries.length) {
        for (const [k, c] of entries) {
          if (c > 0 && (base.get(k) || 0) === 0) base.set(k, 1);
        }
      }
      // Cap by stratum size
      for (const [k, c] of entries) {
        if ((base.get(k) || 0) > c) base.set(k, c);
      }
      // Adjust downward if over
      let current = Array.from(base.values()).reduce((s, v) => s + v, 0);
      while (current > totalSize) {
        const sorted = Array.from(base.entries()).sort((a, b) => b[1] - a[1]);
        for (const [k, v] of sorted) {
          if (current <= totalSize) break;
          if (v > 0) {
            base.set(k, v - 1);
            current -= 1;
          }
        }
      }
      // Redistribute if under and capacity exists
      const target = Math.min(totalSize, total);
      while (current < target) {
        let increased = false;
        for (const [k, c] of entries.sort((a, b) => b[1] - a[1])) {
          if (current >= target) break;
          const have = base.get(k) || 0;
          if (have < c) {
            base.set(k, have + 1);
            current += 1;
            increased = true;
          }
        }
        if (!increased) break;
      }
      return Object.fromEntries(base.entries());
    }

    function distribution(rows, fields) {
      if (!fields.length || !rows.length) return [];
      const counts = {};
      for (const row of rows) {
        const key = normalizeKey(fields.map(f => row[f]));
        counts[key] = (counts[key] || 0) + 1;
      }
      const total = rows.length;
      return Object.entries(counts).map(([key, count]) => {
        const values = JSON.parse(key).map(v => v === MISSING_VALUE ? null : v);
        const stratum = {};
        fields.forEach((f, i) => stratum[f] = values[i]);
        return { stratum, count, share: count / total };
      });
    }

    function stratifiedSample(rows, cfg, rng, desiredSize) {
      const fields = cfg.stratifyFields;
      const totalSize = desiredSize ?? resolveSampleSize(rows.length, cfg);
      if (totalSize <= 0) return { sample: [], allocations: [] };

      const groups = {};
      for (const row of rows) {
        const key = normalizeKey(fields.map(f => row[f]));
        if (!groups[key]) groups[key] = [];
        groups[key].push(row);
      }
      const counts = Object.fromEntries(Object.entries(groups).map(([k, arr]) => [k, arr.length]));
      const allocations = proportionalAllocation(counts, totalSize);
      const actualTotal = Object.values(allocations).reduce((s, v) => s + v, 0);

      const samples = [];
      const allocationSummary = [];
      for (const [key, groupRows] of Object.entries(groups)) {
        const alloc = allocations[key] || 0;
        if (alloc <= 0) continue;
        let chosen = [];
        if (cfg.method === 'systematic') {
          chosen = systematicSample(groupRows, alloc, cfg.systematicRandomStart, rng);
        } else {
          chosen = randomSample(groupRows, alloc, rng);
        }
        const values = JSON.parse(key).map(v => v === MISSING_VALUE ? null : v);
        const stratum = {};
        fields.forEach((f, i) => stratum[f] = values[i]);
        allocationSummary.push({
          stratum,
          population_count: groupRows.length,
          sample_count: chosen.length,
          share_of_population: groupRows.length / rows.length,
          share_of_sample: chosen.length / (actualTotal || 1),
        });
        samples.push(...chosen);
      }
      return { sample: samples, allocations: allocationSummary };
    }

    function buildSummary(population, sample, allocations, cfg, plannedSize) {
      return {
        generated_at_utc: new Date().toISOString(),
        methodology: {
          method: cfg.method,
          confidence: cfg.confidence,
          margin: cfg.margin,
          expected_error_rate: cfg.expectedErrorRate,
          sample_size_parameter: cfg.sampleSize ?? null,
          sample_percentage_parameter: cfg.samplePercentage ?? null,
          systematic_step_parameter: cfg.systematicStep ?? null,
          seed: cfg.seed,
          systematic_random_start: cfg.systematicRandomStart,
          planned_sample_size: plannedSize,
        },
        stratify_fields: cfg.stratifyFields,
        source: {
          file_name: state.fileName,
          sheet_name: state.sheetName,
        },
        population: {
          size: population.length,
          distribution: distribution(population, cfg.stratifyFields),
        },
        sample: {
          size: sample.length,
          distribution: distribution(sample, cfg.stratifyFields),
        },
        allocations,
        sample_ids: cfg.idColumn ? sample.map(r => r[cfg.idColumn]) : undefined,
      };
    }

    function sampleData(population, cfg) {
      const desiredSize = resolveSampleSize(population.length, cfg);
      if (desiredSize <= 0 && population.length > 0) throw new Error('Calculated sample size is 0. Adjust parameters.');

      const rng = rngFactory(cfg.seed ?? 42);
      let sample = [];
      let allocations = [];
      if (cfg.stratifyFields.length) {
        ({ sample, allocations } = stratifiedSample(population, cfg, rng, desiredSize));
      } else {
        if (cfg.method === 'systematic') {
          sample = systematicSample(population, desiredSize, cfg.systematicRandomStart, rng);
        } else {
          sample = randomSample(population, desiredSize, rng);
        }
      }
      const summary = buildSummary(population, sample, allocations, cfg, desiredSize);
      return { sample, summary };
    }

    function toCsv(rows, columns) {
      const escape = (v) => {
        if (v === null || v === undefined) return '';
        const s = String(v).replace(/"/g, '""');
        return /[",\n]/.test(s) ? `"${s}"` : s;
      };
      const header = columns.join(',');
      const lines = rows.map(r => columns.map(c => escape(r[c])).join(','));
      return [header, ...lines].join('\r\n');
    }

    function renderSummary() {
      if (!state.summary) {
        summaryBox.textContent = 'Load data and run sampling to see results.';
        downloadCsvBtn.disabled = true;
        downloadJsonBtn.disabled = true;
        return;
      }
      const s = state.summary;
      const lines = [];
      lines.push(`Selected ${s.sample.size} of ${s.population.size} using "${s.methodology.method}". Planned size: ${s.methodology.planned_sample_size}.`);
      if (s.stratify_fields && s.stratify_fields.length) {
        lines.push(`Stratified by: ${s.stratify_fields.join(', ')}`);
      }
      if (s.allocations && s.allocations.length) {
        lines.push('');
        lines.push('Per-stratum sample counts:');
        s.allocations.forEach(a => {
          const desc = Object.entries(a.stratum || {}).map(([k, v]) => `${k}=${v === null ? 'NULL' : v}`).join(', ');
          lines.push(`- ${desc}: ${a.sample_count} of ${a.population_count} (${(a.share_of_sample * 100).toFixed(1)}% of sample)`);
        });
      }
      summaryBox.textContent = lines.join('\n');
      downloadCsvBtn.disabled = false;
      downloadJsonBtn.disabled = false;
    }

    function readConfigForm() {
      const form = document.getElementById('configForm');
      const method = form.method.value;
      const confidence = parseFloat(form.confidence.value) || 0.99;
      const margin = parseFloat(form.margin.value) || 0.05;
      const expectedError = parseFloat(form.expectedError.value) || 0.01;
      const sampleSizeVal = form.sampleSize.value.trim();
      const samplePctVal = form.samplePct.value.trim();
      const stepVal = form.systematicStep.value.trim();
      const stratifyFields = Array.from(form.querySelectorAll('input[name="stratify"]:checked')).map(cb => cb.value);
      const seed = parseInt(form.seed.value, 10);
      const randomStart = form.randomStart.value === 'yes';
      const idColumn = form.idColumn.value || null;

      return {
        method,
        confidence,
        margin,
        expectedErrorRate: expectedError,
        sampleSize: sampleSizeVal === '' ? null : parseInt(sampleSizeVal, 10),
        samplePercentage: samplePctVal === '' ? null : parseFloat(samplePctVal),
        systematicStep: stepVal === '' ? null : parseInt(stepVal, 10),
        stratifyFields,
        seed: Number.isFinite(seed) ? seed : 42,
        systematicRandomStart: randomStart,
        idColumn,
      };
    }

    function resetAll() {
      state.population = [];
      state.columns = [];
      state.sample = [];
      state.summary = null;
      state.sheetName = null;
      state.fileName = null;
      fileInput.value = '';
      renderColumns();
      renderStratifyOptions();
      renderSummary();
      runBtn.disabled = true;
      sheetNameHint.textContent = '';
      setStatus('Reset. Load a new file.', 'muted');
    }

    document.getElementById('configForm').addEventListener('submit', (e) => {
      e.preventDefault();
      if (!state.population.length) {
        setStatus('Load an Excel file first.', 'danger');
        return;
      }
      try {
        const cfg = readConfigForm();
        const { sample, summary } = sampleData(state.population, cfg);
        state.sample = sample;
        state.summary = summary;
        renderSummary();
        setStatus(`Sample created: ${sample.length} records.`, 'success');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Sampling failed.', 'danger');
      }
    });

    resetBtn.addEventListener('click', resetAll);

    downloadCsvBtn.addEventListener('click', () => {
      if (!state.sample.length) return;
      const csv = toCsv(state.sample, state.columns);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sample.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    downloadJsonBtn.addEventListener('click', () => {
      if (!state.summary) return;
      const blob = new Blob([JSON.stringify(state.summary, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sampling_summary.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    setupDropzone();
    renderSummary();
    setStatus('Ready. Load an Excel file to begin.');
  </script>
</body>
</html>
